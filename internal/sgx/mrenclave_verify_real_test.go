package sgx

import (
	"bytes"
	"encoding/hex"
	"os"
	"testing"
)

// TestVerifyMREnclaveWithRealManifest verifies our MRENCLAVE calculation
// against a real manifest.sgx file generated by Gramine
func TestVerifyMREnclaveWithRealManifest(t *testing.T) {
// Use the real manifest.sgx file we generated with Gramine
manifestPath := "../../gramine/test.manifest.sgx"

// Check if file exists
if _, err := os.Stat(manifestPath); os.IsNotExist(err) {
t.Skip("Real manifest file not found, skipping verification test")
return
}

t.Logf("Reading real manifest file: %s", manifestPath)

// Read the manifest.sgx file
data, err := os.ReadFile(manifestPath)
if err != nil {
t.Fatalf("Failed to read manifest file: %v", err)
}

if len(data) < 1808 {
t.Fatalf("Manifest file too small: %d bytes", len(data))
}

// Extract MRENCLAVE from SIGSTRUCT (offset 960, 32 bytes)
// This is the value Gramine calculated and signed
gramineMREnclave := data[960:992]
t.Logf("Gramine MRENCLAVE (from SIGSTRUCT): %s", hex.EncodeToString(gramineMREnclave))

// Parse the manifest TOML
manifest, err := ParseManifestTOML(data[1808:])
if err != nil {
t.Fatalf("Failed to parse manifest TOML: %v", err)
}

// Calculate trusted files hashes
// Note: For test manifest, we may not have the actual files
// So we'll use empty map for now (manifest may have no trusted files)
fileHashes := make(map[string][]byte)

// Calculate MRENCLAVE using our implementation
ourMREnclave, err := CalculateMREnclave(manifest, fileHashes)
if err != nil {
t.Fatalf("Failed to calculate MRENCLAVE: %v", err)
}

t.Logf("Our calculated MRENCLAVE:          %s", hex.EncodeToString(ourMREnclave))

// Compare the two values
if bytes.Equal(gramineMREnclave, ourMREnclave) {
t.Logf("✓ SUCCESS: MRENCLAVEs MATCH!")
t.Logf("Our implementation correctly matches Gramine's MRENCLAVE calculation")
} else {
t.Logf("✗ FAILURE: MRENCLAVEs DO NOT MATCH")
t.Logf("Gramine MRENCLAVE: %s", hex.EncodeToString(gramineMREnclave))
t.Logf("Our MRENCLAVE:     %s", hex.EncodeToString(ourMREnclave))

// Show byte-by-byte comparison
t.Logf("\nByte-by-byte comparison:")
for i := 0; i < 32; i++ {
if gramineMREnclave[i] != ourMREnclave[i] {
t.Logf("  Byte %2d: Gramine=%02x Our=%02x DIFFER", i, gramineMREnclave[i], ourMREnclave[i])
} else {
t.Logf("  Byte %2d: %02x (match)", i, gramineMREnclave[i])
}
}

t.Errorf("MRENCLAVE mismatch - implementation needs debugging")
}
}

// Helper function to print manifest details for debugging
func TestPrintManifestDetails(t *testing.T) {
manifestPath := "../../gramine/test.manifest.sgx"

if _, err := os.Stat(manifestPath); os.IsNotExist(err) {
t.Skip("Real manifest file not found")
return
}

data, err := os.ReadFile(manifestPath)
if err != nil {
t.Fatalf("Failed to read manifest: %v", err)
}

t.Logf("Manifest file size: %d bytes", len(data))
t.Logf("SIGSTRUCT size: 1808 bytes")
t.Logf("TOML content size: %d bytes", len(data)-1808)

// Parse manifest
manifest, err := ParseManifestTOML(data[1808:])
if err != nil {
t.Logf("Warning: Failed to parse TOML: %v", err)
return
}

t.Logf("\nManifest configuration:")
t.Logf("  Enclave size: %s", manifest.SGX.EnclaveSize)
t.Logf("  Thread num: %d", manifest.SGX.ThreadNum)
t.Logf("  Trusted files: %d", len(manifest.SGX.TrustedFiles))

for i, tf := range manifest.SGX.TrustedFiles {
t.Logf("    File %d: %s", i, tf.URI)
}
}
