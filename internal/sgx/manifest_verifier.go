// Copyright 2024 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.

package sgx

import (
	"bytes"
	"crypto"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/pem"
	"fmt"
	"os"
	"path/filepath"

	"github.com/ethereum/go-ethereum/log"
)

// ManifestSignatureVerifier verifies Gramine manifest file signatures
// Based on Gramine official documentation:
// https://gramine.readthedocs.io/en/stable/manifest-syntax.html
// https://gramine.readthedocs.io/en/stable/sgx-intro.html
//
// Gramine manifest signature workflow:
// 1. Original manifest: <app>.manifest or <app>.manifest.template
// 2. SGX manifest: <app>.manifest.sgx (generated by gramine-manifest)
// 3. Signature file: <app>.manifest.sgx.sig (generated by gramine-sgx-sign)
// 4. Gramine verifies signature at startup before launching the application
type ManifestSignatureVerifier struct {
	publicKey *rsa.PublicKey
}

// NewManifestSignatureVerifier creates a new manifest signature verifier
// The public key can be loaded from environment variable or default location
func NewManifestSignatureVerifier() (*ManifestSignatureVerifier, error) {
	// Try to load public key from environment variable first
	pubKeyPath := os.Getenv("GRAMINE_SIGSTRUCT_KEY_PATH")
	if pubKeyPath == "" {
		// Default locations to search for public key (Gramine standard paths)
		possiblePaths := []string{
			"/gramine/signing_key.pub",      // Container deployment
			"/etc/gramine/signing_key.pub",  // System-wide installation
			"./enclave-key.pub",             // Build directory
			"./signing_key.pub",             // Alternative name
		}

		for _, path := range possiblePaths {
			if _, err := os.Stat(path); err == nil {
				pubKeyPath = path
				break
			}
		}
	}

	if pubKeyPath == "" {
		// In test mode or non-SGX mode, return a verifier that always succeeds
		if os.Getenv("SGX_TEST_MODE") == "true" || os.Getenv("IN_SGX") != "1" {
			return &ManifestSignatureVerifier{publicKey: nil}, nil
		}
		return nil, fmt.Errorf("no public key found for manifest signature verification")
	}

	// Load public key
	pubKey, err := loadRSAPublicKey(pubKeyPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load public key: %w", err)
	}

	return &ManifestSignatureVerifier{
		publicKey: pubKey,
	}, nil
}

// VerifyManifestSignature verifies the signature of a Gramine SGX manifest file
// According to Gramine spec:
// - manifestPath should be the .manifest.sgx file
// - signaturePath should be the .manifest.sgx.sig file (auto-detected if empty)
func (v *ManifestSignatureVerifier) VerifyManifestSignature(manifestPath string, signaturePath string) error {
	// In test mode, skip verification
	if v.publicKey == nil {
		return nil
	}

	// Auto-detect signature path if not provided
	// Gramine convention: <app>.manifest.sgx -> <app>.manifest.sgx.sig
	if signaturePath == "" {
		if filepath.Ext(manifestPath) == ".sgx" {
			signaturePath = manifestPath + ".sig"
		} else {
			// If not .sgx extension, assume it needs .manifest.sgx.sig
			signaturePath = manifestPath + ".manifest.sgx.sig"
		}
	}

	// Read manifest file (.manifest.sgx)
	manifestData, err := os.ReadFile(manifestPath)
	if err != nil {
		return fmt.Errorf("failed to read manifest file: %w", err)
	}

	// Read signature file (.manifest.sgx.sig)
	signatureData, err := os.ReadFile(signaturePath)
	if err != nil {
		return fmt.Errorf("failed to read signature file %s: %w", signaturePath, err)
	}

	// Gramine uses SHA256 hash and RSA-3072 signature
	hash := sha256.Sum256(manifestData)

	// Verify RSA signature (PKCS#1 v1.5)
	err = rsa.VerifyPKCS1v15(v.publicKey, crypto.SHA256, hash[:], signatureData)
	if err != nil {
		return fmt.Errorf("manifest signature verification failed: %w", err)
	}

	return nil
}

// VerifyCurrentManifest verifies the signature of the currently running manifest
// NOTE: In Gramine SGX, the manifest is verified at launch time by Gramine itself.
// This function provides additional runtime verification.
func (v *ManifestSignatureVerifier) VerifyCurrentManifest() error {
	// In test mode, skip verification
	if v.publicKey == nil {
		return nil
	}

	// Try to find the SGX manifest file
	// Gramine standard: application should be launched with <app>.manifest.sgx
	manifestPath := os.Getenv("GRAMINE_MANIFEST_PATH")
	if manifestPath == "" {
		// Try common Gramine deployment locations
		appName := os.Getenv("GRAMINE_APP_NAME")
		if appName == "" {
			appName = "geth" // Default application name
		}

		possiblePaths := []string{
			fmt.Sprintf("/gramine/app_files/%s.manifest.sgx", appName),
			fmt.Sprintf("/gramine/%s.manifest.sgx", appName),
			fmt.Sprintf("./%s.manifest.sgx", appName),
		}

		for _, path := range possiblePaths {
			if _, err := os.Stat(path); err == nil {
				manifestPath = path
				break
			}
		}
	}

	if manifestPath == "" {
		return fmt.Errorf("cannot find manifest file for verification")
	}

	return v.VerifyManifestSignature(manifestPath, "")
}

// loadRSAPublicKey loads an RSA public key from a PEM file
// Gramine uses RSA-3072 keys for manifest signing
func loadRSAPublicKey(path string) (*rsa.PublicKey, error) {
	keyData, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read public key file: %w", err)
	}

	block, _ := pem.Decode(keyData)
	if block == nil {
		return nil, fmt.Errorf("failed to decode PEM block")
	}

	// Try parsing as PKIX public key first (standard format)
	pubKey, err := x509.ParsePKIXPublicKey(block.Bytes)
	if err != nil {
		// Try parsing as PKCS1 RSA public key
		pubKey, err = x509.ParsePKCS1PublicKey(block.Bytes)
		if err != nil {
			return nil, fmt.Errorf("failed to parse public key: %w", err)
		}
	}

	rsaKey, ok := pubKey.(*rsa.PublicKey)
	if !ok {
		return nil, fmt.Errorf("key is not an RSA public key")
	}

	// Verify key size (Gramine uses RSA-3072)
	keyBits := rsaKey.N.BitLen()
	if keyBits != 3072 {
		// Allow other key sizes but warn
		fmt.Printf("Warning: RSA key size is %d bits, Gramine standard is 3072 bits\n", keyBits)
	}

	return rsaKey, nil
}

// VerifyManifestFile is a convenience function that creates a verifier and verifies a manifest
func VerifyManifestFile(manifestPath string) error {
	verifier, err := NewManifestSignatureVerifier()
	if err != nil {
		return fmt.Errorf("failed to create manifest verifier: %w", err)
	}

	return verifier.VerifyManifestSignature(manifestPath, "")
}

// VerifyCurrentManifestFile is a convenience function that verifies the current running manifest
func VerifyCurrentManifestFile() error {
	verifier, err := NewManifestSignatureVerifier()
	if err != nil {
		return fmt.Errorf("failed to create manifest verifier: %w", err)
	}

	return verifier.VerifyCurrentManifest()
}

// ValidateManifestIntegrity performs manifest signature verification
// 
// 重要：虽然Gramine在启动时已验证manifest签名（签名不对起不来），
// 但应用程序要读取manifest文件内容时，必须再次验证签名，
// 因为文件可能在Gramine启动后被修改。
//
// 流程：
// 1. 定位manifest文件（遵循Gramine规范，不硬编码路径）
// 2. 验证manifest签名
// 3. 验证通过后才能读取配置
func ValidateManifestIntegrity() error {
	// Step 1: 检查是否在Gramine环境中
	gramineVersion := os.Getenv("GRAMINE_VERSION")
	if gramineVersion == "" {
		// 非Gramine环境，开发模式
		log.Info("Not running under Gramine - skipping manifest verification")
		return nil
	}
	
	log.Info("Running under Gramine", "version", gramineVersion)
	
	// Step 2: 检查Gramine是否已验证manifest（通过MRENCLAVE存在性）
	mrenclave := os.Getenv("RA_TLS_MRENCLAVE")
	if mrenclave == "" {
		mrenclave = os.Getenv("SGX_MRENCLAVE")
	}
	if mrenclave != "" {
		log.Info("Gramine verified manifest at startup", "MRENCLAVE", mrenclave[:16]+"...")
	} else {
		log.Warn("MRENCLAVE not found - Gramine may not have verified manifest")
	}
	
	// Step 3: 应用层必须自己验证manifest文件签名
	// 因为文件可能在Gramine启动后被修改
	log.Info("Step 3: Application verifying manifest signature...")
	
	// 3.1 定位manifest文件（遵循Gramine规范）
	manifestPath, err := findManifestFile()
	if err != nil {
		return fmt.Errorf("cannot locate manifest file: %w", err)
	}
	log.Info("Located manifest file", "path", manifestPath)
	
	// 3.2 验证签名
	verifier, err := NewManifestSignatureVerifier()
	if err != nil {
		return fmt.Errorf("failed to create manifest verifier: %w", err)
	}
	
	if err := verifier.VerifyManifestSignature(manifestPath, ""); err != nil {
		return fmt.Errorf("manifest signature verification FAILED: %w", err)
	}
	
	log.Info("✓ Manifest signature verified by application")
	
	return nil
}

// findManifestFile locates the manifest file following Gramine conventions
// 遵循Gramine规范，不硬编码路径
func findManifestFile() (string, error) {
	// Method 1: Use environment variable (Gramine standard)
	if path := os.Getenv("GRAMINE_MANIFEST_PATH"); path != "" {
		if _, err := os.Stat(path); err == nil {
			return path, nil
		}
	}
	
	// Method 2: Use current working directory + app name
	// Gramine convention: executable is in same dir as manifest
	appName := os.Getenv("GRAMINE_APP_NAME")
	if appName == "" {
		// Get app name from executable path
		if exe, err := os.Executable(); err == nil {
			appName = filepath.Base(exe)
		} else {
			appName = "geth" // fallback
		}
	}
	
	// Try: <appname>.manifest.sgx in current directory
	manifestName := appName + ".manifest.sgx"
	if _, err := os.Stat(manifestName); err == nil {
		return manifestName, nil
	}
	
	// Method 3: Check /proc/self/root (Gramine mounts)
	// 注意：这是Gramine的特殊路径，应用看到的是映射后的路径
	
	return "", fmt.Errorf("manifest file not found (tried GRAMINE_MANIFEST_PATH env var and %s)", manifestName)
}

// GetManifestPath returns the path to the SGX manifest file
// 遵循Gramine规范：优先使用环境变量，不硬编码路径
func GetManifestPath() (string, error) {
	return findManifestFile()
}

// MustVerifyManifest verifies the manifest and panics if verification fails
// This should be called at the start of sensitive operations
func MustVerifyManifest() {
	if err := ValidateManifestIntegrity(); err != nil {
		panic(fmt.Sprintf("CRITICAL: Manifest integrity validation failed: %v", err))
	}
}

// GetMRENCLAVE returns the MRENCLAVE measurement from environment
// This proves the manifest was verified by Gramine
func GetMRENCLAVE() (string, error) {
	mrenclave := os.Getenv("RA_TLS_MRENCLAVE")
	if mrenclave == "" {
		mrenclave = os.Getenv("SGX_MRENCLAVE")
	}

	if mrenclave == "" {
		return "", fmt.Errorf("MRENCLAVE not found in environment")
	}

	return mrenclave, nil
}

// GetMRSIGNER returns the MRSIGNER measurement from environment
// This identifies the signer of the manifest
func GetMRSIGNER() (string, error) {
	mrsigner := os.Getenv("RA_TLS_MRSIGNER")
	if mrsigner == "" {
		mrsigner = os.Getenv("SGX_MRSIGNER")
	}

	if mrsigner == "" {
		return "", fmt.Errorf("MRSIGNER not found in environment")
	}

	return mrsigner, nil
}

// ReadContractAddressesFromManifest reads contract addresses from verified manifest
// 必须先调用 ValidateManifestIntegrity() 验证签名后才能调用此函数
func ReadContractAddressesFromManifest() (governance, security string, err error) {
// 1. 定位manifest文件
manifestPath, err := findManifestFile()
if err != nil {
return "", "", fmt.Errorf("cannot locate manifest: %w", err)
}

// 2. 再次验证签名（防御性编程）
verifier, err := NewManifestSignatureVerifier()
if err != nil {
return "", "", fmt.Errorf("failed to create verifier: %w", err)
}

if err := verifier.VerifyManifestSignature(manifestPath, ""); err != nil {
return "", "", fmt.Errorf("manifest signature verification failed: %w", err)
}

// 3. 读取manifest文件
data, err := os.ReadFile(manifestPath)
if err != nil {
return "", "", fmt.Errorf("failed to read manifest: %w", err)
}

// 4. 解析manifest文件获取环境变量
// Gramine manifest格式：loader.env.VARNAME = "value"
govAddr := parseManifestEnvVar(data, "XCHAIN_GOVERNANCE_CONTRACT")
secAddr := parseManifestEnvVar(data, "XCHAIN_SECURITY_CONFIG_CONTRACT")

if govAddr == "" || secAddr == "" {
return "", "", fmt.Errorf("contract addresses not found in manifest")
}

log.Info("Contract addresses read from manifest",
"governance", govAddr,
"security", secAddr)

return govAddr, secAddr, nil
}

// parseManifestEnvVar extracts environment variable value from manifest content
// Gramine manifest format: loader.env.VARNAME = "value"
func parseManifestEnvVar(data []byte, varName string) string {
	// Simple line-by-line parsing
	lines := bytes.Split(data, []byte("\n"))
	prefix := []byte(fmt.Sprintf("loader.env.%s", varName))
	
	for _, line := range lines {
		line = bytes.TrimSpace(line)
		if bytes.HasPrefix(line, prefix) {
			// Extract value between quotes
			parts := bytes.Split(line, []byte("\""))
			if len(parts) >= 2 {
				return string(parts[1])
			}
		}
	}
	
	return ""
}
