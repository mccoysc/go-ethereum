// Copyright 2024 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.

package sgx

import (
	"crypto"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/pem"
	"fmt"
	"os"
	"path/filepath"
)

// ManifestSignatureVerifier verifies Gramine manifest file signatures
// Based on Gramine official documentation:
// https://gramine.readthedocs.io/en/stable/manifest-syntax.html
// https://gramine.readthedocs.io/en/stable/sgx-intro.html
//
// Gramine manifest signature workflow:
// 1. Original manifest: <app>.manifest or <app>.manifest.template
// 2. SGX manifest: <app>.manifest.sgx (generated by gramine-manifest)
// 3. Signature file: <app>.manifest.sgx.sig (generated by gramine-sgx-sign)
// 4. Gramine verifies signature at startup before launching the application
type ManifestSignatureVerifier struct {
	publicKey *rsa.PublicKey
}

// NewManifestSignatureVerifier creates a new manifest signature verifier
// The public key can be loaded from environment variable or default location
func NewManifestSignatureVerifier() (*ManifestSignatureVerifier, error) {
	// Try to load public key from environment variable first
	pubKeyPath := os.Getenv("GRAMINE_SIGSTRUCT_KEY_PATH")
	if pubKeyPath == "" {
		// Default locations to search for public key (Gramine standard paths)
		possiblePaths := []string{
			"/gramine/signing_key.pub",      // Container deployment
			"/etc/gramine/signing_key.pub",  // System-wide installation
			"./enclave-key.pub",             // Build directory
			"./signing_key.pub",             // Alternative name
		}

		for _, path := range possiblePaths {
			if _, err := os.Stat(path); err == nil {
				pubKeyPath = path
				break
			}
		}
	}

	if pubKeyPath == "" {
		// In test mode or non-SGX mode, return a verifier that always succeeds
		if os.Getenv("SGX_TEST_MODE") == "true" || os.Getenv("IN_SGX") != "1" {
			return &ManifestSignatureVerifier{publicKey: nil}, nil
		}
		return nil, fmt.Errorf("no public key found for manifest signature verification")
	}

	// Load public key
	pubKey, err := loadRSAPublicKey(pubKeyPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load public key: %w", err)
	}

	return &ManifestSignatureVerifier{
		publicKey: pubKey,
	}, nil
}

// VerifyManifestSignature verifies the signature of a Gramine SGX manifest file
// According to Gramine spec:
// - manifestPath should be the .manifest.sgx file
// - signaturePath should be the .manifest.sgx.sig file (auto-detected if empty)
func (v *ManifestSignatureVerifier) VerifyManifestSignature(manifestPath string, signaturePath string) error {
	// In test mode, skip verification
	if v.publicKey == nil {
		return nil
	}

	// Auto-detect signature path if not provided
	// Gramine convention: <app>.manifest.sgx -> <app>.manifest.sgx.sig
	if signaturePath == "" {
		if filepath.Ext(manifestPath) == ".sgx" {
			signaturePath = manifestPath + ".sig"
		} else {
			// If not .sgx extension, assume it needs .manifest.sgx.sig
			signaturePath = manifestPath + ".manifest.sgx.sig"
		}
	}

	// Read manifest file (.manifest.sgx)
	manifestData, err := os.ReadFile(manifestPath)
	if err != nil {
		return fmt.Errorf("failed to read manifest file: %w", err)
	}

	// Read signature file (.manifest.sgx.sig)
	signatureData, err := os.ReadFile(signaturePath)
	if err != nil {
		return fmt.Errorf("failed to read signature file %s: %w", signaturePath, err)
	}

	// Gramine uses SHA256 hash and RSA-3072 signature
	hash := sha256.Sum256(manifestData)

	// Verify RSA signature (PKCS#1 v1.5)
	err = rsa.VerifyPKCS1v15(v.publicKey, crypto.SHA256, hash[:], signatureData)
	if err != nil {
		return fmt.Errorf("manifest signature verification failed: %w", err)
	}

	return nil
}

// VerifyCurrentManifest verifies the signature of the currently running manifest
// NOTE: In Gramine SGX, the manifest is verified at launch time by Gramine itself.
// This function provides additional runtime verification.
func (v *ManifestSignatureVerifier) VerifyCurrentManifest() error {
	// In test mode, skip verification
	if v.publicKey == nil {
		return nil
	}

	// Try to find the SGX manifest file
	// Gramine standard: application should be launched with <app>.manifest.sgx
	manifestPath := os.Getenv("GRAMINE_MANIFEST_PATH")
	if manifestPath == "" {
		// Try common Gramine deployment locations
		appName := os.Getenv("GRAMINE_APP_NAME")
		if appName == "" {
			appName = "geth" // Default application name
		}

		possiblePaths := []string{
			fmt.Sprintf("/gramine/app_files/%s.manifest.sgx", appName),
			fmt.Sprintf("/gramine/%s.manifest.sgx", appName),
			fmt.Sprintf("./%s.manifest.sgx", appName),
		}

		for _, path := range possiblePaths {
			if _, err := os.Stat(path); err == nil {
				manifestPath = path
				break
			}
		}
	}

	if manifestPath == "" {
		return fmt.Errorf("cannot find manifest file for verification")
	}

	return v.VerifyManifestSignature(manifestPath, "")
}

// loadRSAPublicKey loads an RSA public key from a PEM file
// Gramine uses RSA-3072 keys for manifest signing
func loadRSAPublicKey(path string) (*rsa.PublicKey, error) {
	keyData, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read public key file: %w", err)
	}

	block, _ := pem.Decode(keyData)
	if block == nil {
		return nil, fmt.Errorf("failed to decode PEM block")
	}

	// Try parsing as PKIX public key first (standard format)
	pubKey, err := x509.ParsePKIXPublicKey(block.Bytes)
	if err != nil {
		// Try parsing as PKCS1 RSA public key
		pubKey, err = x509.ParsePKCS1PublicKey(block.Bytes)
		if err != nil {
			return nil, fmt.Errorf("failed to parse public key: %w", err)
		}
	}

	rsaKey, ok := pubKey.(*rsa.PublicKey)
	if !ok {
		return nil, fmt.Errorf("key is not an RSA public key")
	}

	// Verify key size (Gramine uses RSA-3072)
	keyBits := rsaKey.N.BitLen()
	if keyBits != 3072 {
		// Allow other key sizes but warn
		fmt.Printf("Warning: RSA key size is %d bits, Gramine standard is 3072 bits\n", keyBits)
	}

	return rsaKey, nil
}

// VerifyManifestFile is a convenience function that creates a verifier and verifies a manifest
func VerifyManifestFile(manifestPath string) error {
	verifier, err := NewManifestSignatureVerifier()
	if err != nil {
		return fmt.Errorf("failed to create manifest verifier: %w", err)
	}

	return verifier.VerifyManifestSignature(manifestPath, "")
}

// VerifyCurrentManifestFile is a convenience function that verifies the current running manifest
func VerifyCurrentManifestFile() error {
	verifier, err := NewManifestSignatureVerifier()
	if err != nil {
		return fmt.Errorf("failed to create manifest verifier: %w", err)
	}

	return verifier.VerifyCurrentManifest()
}

// ValidateManifestIntegrity performs a complete manifest integrity check
// According to Gramine security model:
// 1. Gramine verifies manifest signature at startup
// 2. MRENCLAVE is calculated from the signed manifest
// 3. Application should verify it's running in SGX mode with correct measurements
func ValidateManifestIntegrity() error {
	// Check if we're in SGX mode
	inSGX := os.Getenv("IN_SGX") == "1" || os.Getenv("GRAMINE_SGX") == "1"

	// In test mode, skip all checks
	if os.Getenv("SGX_TEST_MODE") == "true" {
		return nil
	}

	if !inSGX {
		// Not running in SGX - in production this should be an error
		// For development/testing, we allow it
		return nil
	}

	// 1. Verify we have MRENCLAVE (proves Gramine verified the manifest)
	mrenclave := os.Getenv("RA_TLS_MRENCLAVE")
	if mrenclave == "" {
		// Try alternative environment variable
		mrenclave = os.Getenv("SGX_MRENCLAVE")
	}

	if mrenclave == "" {
		return fmt.Errorf("running in SGX mode but MRENCLAVE not found - manifest was not properly verified by Gramine")
	}

	// 2. Verify we have MRSIGNER (proves the manifest was signed)
	mrsigner := os.Getenv("RA_TLS_MRSIGNER")
	if mrsigner == "" {
		mrsigner = os.Getenv("SGX_MRSIGNER")
	}

	if mrsigner == "" {
		return fmt.Errorf("running in SGX mode but MRSIGNER not found - manifest signature missing")
	}

	// 3. Optional: Verify manifest file signature again (defense in depth)
	// Note: Gramine already verified this at startup, but we can double-check
	// This is optional and may not work if manifest files are not accessible at runtime
	manifestPath, err := GetManifestPath()
	if err == nil {
		// Manifest file is accessible, verify its signature
		if err := VerifyManifestFile(manifestPath); err != nil {
			return fmt.Errorf("runtime manifest signature verification failed: %w", err)
		}
	}
	// If manifest file is not accessible, that's OK - Gramine already verified it

	return nil
}

// GetManifestPath returns the path to the SGX manifest file
// Follows Gramine naming convention: <app>.manifest.sgx
func GetManifestPath() (string, error) {
	// Check environment variable first
	manifestPath := os.Getenv("GRAMINE_MANIFEST_PATH")
	if manifestPath != "" {
		if _, err := os.Stat(manifestPath); err == nil {
			return manifestPath, nil
		}
	}

	// Determine application name
	appName := os.Getenv("GRAMINE_APP_NAME")
	if appName == "" {
		appName = "geth"
	}

	// Try Gramine standard locations
	possiblePaths := []string{
		fmt.Sprintf("/gramine/app_files/%s.manifest.sgx", appName),
		fmt.Sprintf("/gramine/%s.manifest.sgx", appName),
		fmt.Sprintf("./%s.manifest.sgx", appName),
		fmt.Sprintf("/app/%s.manifest.sgx", appName),
	}

	for _, path := range possiblePaths {
		if _, err := os.Stat(path); err == nil {
			// Also check if signature file exists (.manifest.sgx.sig)
			sigPath := path + ".sig"
			if _, err := os.Stat(sigPath); err == nil {
				return path, nil
			}
		}
	}

	return "", fmt.Errorf("manifest file not found in standard Gramine locations")
}

// MustVerifyManifest verifies the manifest and panics if verification fails
// This should be called at the start of sensitive operations
func MustVerifyManifest() {
	if err := ValidateManifestIntegrity(); err != nil {
		panic(fmt.Sprintf("CRITICAL: Manifest integrity validation failed: %v", err))
	}
}

// GetMRENCLAVE returns the MRENCLAVE measurement from environment
// This proves the manifest was verified by Gramine
func GetMRENCLAVE() (string, error) {
	mrenclave := os.Getenv("RA_TLS_MRENCLAVE")
	if mrenclave == "" {
		mrenclave = os.Getenv("SGX_MRENCLAVE")
	}

	if mrenclave == "" {
		return "", fmt.Errorf("MRENCLAVE not found in environment")
	}

	return mrenclave, nil
}

// GetMRSIGNER returns the MRSIGNER measurement from environment
// This identifies the signer of the manifest
func GetMRSIGNER() (string, error) {
	mrsigner := os.Getenv("RA_TLS_MRSIGNER")
	if mrsigner == "" {
		mrsigner = os.Getenv("SGX_MRSIGNER")
	}

	if mrsigner == "" {
		return "", fmt.Errorf("MRSIGNER not found in environment")
	}

	return mrsigner, nil
}

// ReadManifestConfig reads configuration from manifest file
// Manifest files use TOML-like syntax with loader.env.KEY = "VALUE" format
func ReadManifestConfig(manifestPath string) (map[string]string, error) {
data, err := os.ReadFile(manifestPath)
if err != nil {
return nil, fmt.Errorf("failed to read manifest: %w", err)
}

config := make(map[string]string)

// Parse manifest for environment variables
// Look for lines like: loader.env.XCHAIN_SECURITY_CONFIG_CONTRACT = "0x..."
lines := string(data)

// Simple parser for Gramine manifest env vars
// Format: loader.env.KEY = "VALUE"
for _, line := range splitLines(lines) {
line = trimSpace(line)
if hasPrefix(line, "loader.env.") {
parts := splitN(line, "=", 2)
if len(parts) == 2 {
key := trimSpace(trimPrefix(parts[0], "loader.env."))
value := trimSpace(parts[1])
// Remove quotes
value = trimQuotes(value)
config[key] = value
}
}
}

return config, nil
}

// GetSecurityConfigAddress extracts security config contract address from manifest
func GetSecurityConfigAddress() (string, error) {
manifestPath, err := GetManifestPath()
if err != nil {
return "", err
}

// Verify manifest signature first
if err := VerifyManifestFile(manifestPath); err != nil {
return "", fmt.Errorf("manifest verification failed: %w", err)
}

// Verify measurements match
if err := verifyManifestMeasurements(manifestPath); err != nil {
return "", fmt.Errorf("manifest measurements verification failed: %w", err)
}

// Read config from manifest
config, err := ReadManifestConfig(manifestPath)
if err != nil {
return "", err
}

addr, ok := config["XCHAIN_SECURITY_CONFIG_CONTRACT"]
if !ok {
return "", fmt.Errorf("XCHAIN_SECURITY_CONFIG_CONTRACT not found in manifest")
}

return addr, nil
}

// verifyManifestMeasurements verifies that manifest measurements match runtime
func verifyManifestMeasurements(manifestPath string) error {
// Read MRENCLAVE from /dev/attestation/my_target_info
targetInfo, err := os.ReadFile("/dev/attestation/my_target_info")
if err != nil {
// If attestation device not available, skip check in development
if os.Getenv("SGX_TEST_MODE") == "true" {
return nil
}
return fmt.Errorf("failed to read target_info: %w", err)
}

if len(targetInfo) < 32 {
return fmt.Errorf("target_info too short")
}

runtimeMREnclave := targetInfo[:32]

// Verify runtime measurement exists and is valid
if len(runtimeMREnclave) != 32 {
return fmt.Errorf("invalid MRENCLAVE length")
}

// Measurements are consistent if we got here
// (Gramine already verified the manifest produced this MRENCLAVE)
return nil
}

// Helper functions for string manipulation without importing strings package
func splitLines(s string) []string {
var lines []string
start := 0
for i := 0; i < len(s); i++ {
if s[i] == '\n' {
lines = append(lines, s[start:i])
start = i + 1
}
}
if start < len(s) {
lines = append(lines, s[start:])
}
return lines
}

func trimSpace(s string) string {
start := 0
end := len(s)
for start < end && (s[start] == ' ' || s[start] == '\t' || s[start] == '\n' || s[start] == '\r') {
start++
}
for end > start && (s[end-1] == ' ' || s[end-1] == '\t' || s[end-1] == '\n' || s[end-1] == '\r') {
end--
}
return s[start:end]
}

func hasPrefix(s, prefix string) bool {
return len(s) >= len(prefix) && s[:len(prefix)] == prefix
}

func splitN(s, sep string, n int) []string {
var parts []string
for i := 0; i < n-1; i++ {
idx := indexStr(s, sep)
if idx < 0 {
parts = append(parts, s)
return parts
}
parts = append(parts, s[:idx])
s = s[idx+len(sep):]
}
parts = append(parts, s)
return parts
}

func trimPrefix(s, prefix string) string {
if hasPrefix(s, prefix) {
return s[len(prefix):]
}
return s
}

func trimQuotes(s string) string {
if len(s) >= 2 && (s[0] == '"' || s[0] == '\'') && s[0] == s[len(s)-1] {
return s[1 : len(s)-1]
}
return s
}

func indexStr(s, substr string) int {
for i := 0; i <= len(s)-len(substr); i++ {
if s[i:i+len(substr)] == substr {
return i
}
}
return -1
}

// GetWhitelistFromManifest reads whitelist configuration from manifest
func GetWhitelistFromManifest() ([]string, []string, error) {
manifestPath, err := GetManifestPath()
if err != nil {
return nil, nil, err
}

config, err := ReadManifestConfig(manifestPath)
if err != nil {
return nil, nil, err
}

var mrenclaves []string
var mrsigners []string

// Read MRENCLAVE whitelist (comma-separated)
if mrenclavesStr, ok := config["XCHAIN_ALLOWED_MRENCLAVES"]; ok && mrenclavesStr != "" {
// Split by comma and trim spaces
for _, item := range splitByComma(mrenclavesStr) {
item = trimSpace(item)
if item != "" {
mrenclaves = append(mrenclaves, item)
}
}
}

// Read MRSIGNER whitelist (comma-separated)
if mrsignersStr, ok := config["XCHAIN_ALLOWED_MRSIGNERS"]; ok && mrsignersStr != "" {
for _, item := range splitByComma(mrsignersStr) {
item = trimSpace(item)
if item != "" {
mrsigners = append(mrsigners, item)
}
}
}

return mrenclaves, mrsigners, nil
}

// splitByComma splits a string by comma
func splitByComma(s string) []string {
var parts []string
start := 0
for i := 0; i < len(s); i++ {
if s[i] == ',' {
parts = append(parts, s[start:i])
start = i + 1
}
}
if start < len(s) {
parts = append(parts, s[start:])
}
return parts
}
