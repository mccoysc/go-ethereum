// Copyright 2024 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.

package sgx

import (
	"crypto"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/pem"
	"fmt"
	"os"
	"path/filepath"
)

// ManifestSignatureVerifier verifies Gramine manifest file signatures
// Based on Gramine official documentation:
// https://gramine.readthedocs.io/en/stable/manifest-syntax.html
// https://gramine.readthedocs.io/en/stable/sgx-intro.html
//
// Gramine manifest signature workflow:
// 1. Original manifest: <app>.manifest or <app>.manifest.template
// 2. SGX manifest: <app>.manifest.sgx (generated by gramine-manifest)
// 3. Signature file: <app>.manifest.sgx.sig (generated by gramine-sgx-sign)
// 4. Gramine verifies signature at startup before launching the application
type ManifestSignatureVerifier struct {
	publicKey *rsa.PublicKey
}

// NewManifestSignatureVerifier creates a new manifest signature verifier
// The public key can be loaded from environment variable or default location
func NewManifestSignatureVerifier() (*ManifestSignatureVerifier, error) {
	// Try to load public key from environment variable first
	pubKeyPath := os.Getenv("GRAMINE_SIGSTRUCT_KEY_PATH")
	if pubKeyPath == "" {
		// Default locations to search for public key (Gramine standard paths)
		possiblePaths := []string{
			"/gramine/signing_key.pub",      // Container deployment
			"/etc/gramine/signing_key.pub",  // System-wide installation
			"./enclave-key.pub",             // Build directory
			"./signing_key.pub",             // Alternative name
		}

		for _, path := range possiblePaths {
			if _, err := os.Stat(path); err == nil {
				pubKeyPath = path
				break
			}
		}
	}

	if pubKeyPath == "" {
		// In test mode or non-SGX mode, return a verifier that always succeeds
		if os.Getenv("SGX_TEST_MODE") == "true" || os.Getenv("IN_SGX") != "1" {
			return &ManifestSignatureVerifier{publicKey: nil}, nil
		}
		return nil, fmt.Errorf("no public key found for manifest signature verification")
	}

	// Load public key
	pubKey, err := loadRSAPublicKey(pubKeyPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load public key: %w", err)
	}

	return &ManifestSignatureVerifier{
		publicKey: pubKey,
	}, nil
}

// VerifyManifestSignature verifies the signature of a Gramine SGX manifest file
// According to Gramine spec:
// - manifestPath should be the .manifest.sgx file
// - signaturePath should be the .manifest.sgx.sig file (auto-detected if empty)
func (v *ManifestSignatureVerifier) VerifyManifestSignature(manifestPath string, signaturePath string) error {
	// In test mode, skip verification
	if v.publicKey == nil {
		return nil
	}

	// Auto-detect signature path if not provided
	// Gramine convention: <app>.manifest.sgx -> <app>.manifest.sgx.sig
	if signaturePath == "" {
		if filepath.Ext(manifestPath) == ".sgx" {
			signaturePath = manifestPath + ".sig"
		} else {
			// If not .sgx extension, assume it needs .manifest.sgx.sig
			signaturePath = manifestPath + ".manifest.sgx.sig"
		}
	}

	// Read manifest file (.manifest.sgx)
	manifestData, err := os.ReadFile(manifestPath)
	if err != nil {
		return fmt.Errorf("failed to read manifest file: %w", err)
	}

	// Read signature file (.manifest.sgx.sig)
	signatureData, err := os.ReadFile(signaturePath)
	if err != nil {
		return fmt.Errorf("failed to read signature file %s: %w", signaturePath, err)
	}

	// Gramine uses SHA256 hash and RSA-3072 signature
	hash := sha256.Sum256(manifestData)

	// Verify RSA signature (PKCS#1 v1.5)
	err = rsa.VerifyPKCS1v15(v.publicKey, crypto.SHA256, hash[:], signatureData)
	if err != nil {
		return fmt.Errorf("manifest signature verification failed: %w", err)
	}

	return nil
}

// VerifyCurrentManifest verifies the signature of the currently running manifest
// NOTE: In Gramine SGX, the manifest is verified at launch time by Gramine itself.
// This function provides additional runtime verification.
func (v *ManifestSignatureVerifier) VerifyCurrentManifest() error {
	// In test mode, skip verification
	if v.publicKey == nil {
		return nil
	}

	// Try to find the SGX manifest file
	// Gramine standard: application should be launched with <app>.manifest.sgx
	manifestPath := os.Getenv("GRAMINE_MANIFEST_PATH")
	if manifestPath == "" {
		// Try common Gramine deployment locations
		appName := os.Getenv("GRAMINE_APP_NAME")
		if appName == "" {
			appName = "geth" // Default application name
		}

		possiblePaths := []string{
			fmt.Sprintf("/gramine/app_files/%s.manifest.sgx", appName),
			fmt.Sprintf("/gramine/%s.manifest.sgx", appName),
			fmt.Sprintf("./%s.manifest.sgx", appName),
		}

		for _, path := range possiblePaths {
			if _, err := os.Stat(path); err == nil {
				manifestPath = path
				break
			}
		}
	}

	if manifestPath == "" {
		return fmt.Errorf("cannot find manifest file for verification")
	}

	return v.VerifyManifestSignature(manifestPath, "")
}

// loadRSAPublicKey loads an RSA public key from a PEM file
// Gramine uses RSA-3072 keys for manifest signing
func loadRSAPublicKey(path string) (*rsa.PublicKey, error) {
	keyData, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read public key file: %w", err)
	}

	block, _ := pem.Decode(keyData)
	if block == nil {
		return nil, fmt.Errorf("failed to decode PEM block")
	}

	// Try parsing as PKIX public key first (standard format)
	pubKey, err := x509.ParsePKIXPublicKey(block.Bytes)
	if err != nil {
		// Try parsing as PKCS1 RSA public key
		pubKey, err = x509.ParsePKCS1PublicKey(block.Bytes)
		if err != nil {
			return nil, fmt.Errorf("failed to parse public key: %w", err)
		}
	}

	rsaKey, ok := pubKey.(*rsa.PublicKey)
	if !ok {
		return nil, fmt.Errorf("key is not an RSA public key")
	}

	// Verify key size (Gramine uses RSA-3072)
	keyBits := rsaKey.N.BitLen()
	if keyBits != 3072 {
		// Allow other key sizes but warn
		fmt.Printf("Warning: RSA key size is %d bits, Gramine standard is 3072 bits\n", keyBits)
	}

	return rsaKey, nil
}

// VerifyManifestFile is a convenience function that creates a verifier and verifies a manifest
func VerifyManifestFile(manifestPath string) error {
	verifier, err := NewManifestSignatureVerifier()
	if err != nil {
		return fmt.Errorf("failed to create manifest verifier: %w", err)
	}

	return verifier.VerifyManifestSignature(manifestPath, "")
}

// VerifyCurrentManifestFile is a convenience function that verifies the current running manifest
func VerifyCurrentManifestFile() error {
	verifier, err := NewManifestSignatureVerifier()
	if err != nil {
		return fmt.Errorf("failed to create manifest verifier: %w", err)
	}

	return verifier.VerifyCurrentManifest()
}

// ValidateManifestIntegrity performs a complete manifest integrity check
// According to Gramine security model:
// 1. Gramine verifies manifest signature at startup
// 2. MRENCLAVE is calculated from the signed manifest
// 3. Application should verify it's running in SGX mode with correct measurements
func ValidateManifestIntegrity() error {
	// Check if we're in SGX mode
	inSGX := os.Getenv("IN_SGX") == "1" || os.Getenv("GRAMINE_SGX") == "1"

	// In test mode, skip all checks
	if os.Getenv("SGX_TEST_MODE") == "true" {
		return nil
	}

	if !inSGX {
		// Not running in SGX - in production this should be an error
		// For development/testing, we allow it
		return nil
	}

	// 1. Verify we have MRENCLAVE (proves Gramine verified the manifest)
	mrenclave := os.Getenv("RA_TLS_MRENCLAVE")
	if mrenclave == "" {
		// Try alternative environment variable
		mrenclave = os.Getenv("SGX_MRENCLAVE")
	}

	if mrenclave == "" {
		return fmt.Errorf("running in SGX mode but MRENCLAVE not found - manifest was not properly verified by Gramine")
	}

	// 2. Verify we have MRSIGNER (proves the manifest was signed)
	mrsigner := os.Getenv("RA_TLS_MRSIGNER")
	if mrsigner == "" {
		mrsigner = os.Getenv("SGX_MRSIGNER")
	}

	if mrsigner == "" {
		return fmt.Errorf("running in SGX mode but MRSIGNER not found - manifest signature missing")
	}

	// 3. Optional: Verify manifest file signature again (defense in depth)
	// Note: Gramine already verified this at startup, but we can double-check
	// This is optional and may not work if manifest files are not accessible at runtime
	manifestPath, err := GetManifestPath()
	if err == nil {
		// Manifest file is accessible, verify its signature
		if err := VerifyManifestFile(manifestPath); err != nil {
			return fmt.Errorf("runtime manifest signature verification failed: %w", err)
		}
	}
	// If manifest file is not accessible, that's OK - Gramine already verified it

	return nil
}

// GetManifestPath returns the path to the SGX manifest file
// Follows Gramine naming convention: <app>.manifest.sgx
func GetManifestPath() (string, error) {
	// Check environment variable first
	manifestPath := os.Getenv("GRAMINE_MANIFEST_PATH")
	if manifestPath != "" {
		if _, err := os.Stat(manifestPath); err == nil {
			return manifestPath, nil
		}
	}

	// Determine application name
	appName := os.Getenv("GRAMINE_APP_NAME")
	if appName == "" {
		appName = "geth"
	}

	// Try Gramine standard locations
	possiblePaths := []string{
		fmt.Sprintf("/gramine/app_files/%s.manifest.sgx", appName),
		fmt.Sprintf("/gramine/%s.manifest.sgx", appName),
		fmt.Sprintf("./%s.manifest.sgx", appName),
		fmt.Sprintf("/app/%s.manifest.sgx", appName),
	}

	for _, path := range possiblePaths {
		if _, err := os.Stat(path); err == nil {
			// Also check if signature file exists (.manifest.sgx.sig)
			sigPath := path + ".sig"
			if _, err := os.Stat(sigPath); err == nil {
				return path, nil
			}
		}
	}

	return "", fmt.Errorf("manifest file not found in standard Gramine locations")
}

// MustVerifyManifest verifies the manifest and panics if verification fails
// This should be called at the start of sensitive operations
func MustVerifyManifest() {
	if err := ValidateManifestIntegrity(); err != nil {
		panic(fmt.Sprintf("CRITICAL: Manifest integrity validation failed: %v", err))
	}
}

// GetMRENCLAVE returns the MRENCLAVE measurement from environment
// This proves the manifest was verified by Gramine
func GetMRENCLAVE() (string, error) {
	mrenclave := os.Getenv("RA_TLS_MRENCLAVE")
	if mrenclave == "" {
		mrenclave = os.Getenv("SGX_MRENCLAVE")
	}

	if mrenclave == "" {
		return "", fmt.Errorf("MRENCLAVE not found in environment")
	}

	return mrenclave, nil
}

// GetMRSIGNER returns the MRSIGNER measurement from environment
// This identifies the signer of the manifest
func GetMRSIGNER() (string, error) {
	mrsigner := os.Getenv("RA_TLS_MRSIGNER")
	if mrsigner == "" {
		mrsigner = os.Getenv("SGX_MRSIGNER")
	}

	if mrsigner == "" {
		return "", fmt.Errorf("MRSIGNER not found in environment")
	}

	return mrsigner, nil
}
