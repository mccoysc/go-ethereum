// Copyright 2024 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.

package sgx

import (
	"bytes"
	"crypto"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/hex"
	"encoding/pem"
	"fmt"
	"os"
	"path/filepath"

	"github.com/ethereum/go-ethereum/log"
)

// min returns the minimum of two integers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// ManifestSignatureVerifier verifies Gramine manifest file signatures
// Based on Gramine official documentation:
// https://gramine.readthedocs.io/en/stable/manifest-syntax.html
// https://gramine.readthedocs.io/en/stable/sgx-intro.html
//
// Gramine manifest signature workflow:
// 1. Original manifest: <app>.manifest or <app>.manifest.template
// 2. SGX manifest: <app>.manifest.sgx (generated by gramine-manifest)
// 3. Signature file: <app>.manifest.sgx.sig (generated by gramine-sgx-sign)
// 4. Gramine verifies signature at startup before launching the application
type ManifestSignatureVerifier struct {
	publicKey *rsa.PublicKey
}

// NewManifestSignatureVerifier creates a new manifest signature verifier
// The public key can be loaded from environment variable or default location
//
// SECURITY: NO test mode bypass allowed
// For testing: provide real test manifest and signing key
func NewManifestSignatureVerifier() (*ManifestSignatureVerifier, error) {
	// Try to load public key from environment variable first
	pubKeyPath := os.Getenv("GRAMINE_SIGSTRUCT_KEY_PATH")
	if pubKeyPath == "" {
		// Default locations to search for public key (Gramine standard paths)
		possiblePaths := []string{
			"/gramine/signing_key.pub",      // Container deployment
			"/etc/gramine/signing_key.pub",  // System-wide installation
			"./enclave-key.pub",             // Build directory
			"./signing_key.pub",             // Alternative name
			"gramine/enclave-key.pub",       // Relative path
			"test/keys/test-signing-key.pub", // Test key location
		}

		for _, path := range possiblePaths {
			if _, err := os.Stat(path); err == nil {
				pubKeyPath = path
				break
			}
		}
	}

	if pubKeyPath == "" {
		return nil, fmt.Errorf("SECURITY: No public key found for manifest signature verification. " +
			"Searched standard locations. " +
			"Set GRAMINE_SIGSTRUCT_KEY_PATH or place signing_key.pub in standard location. " +
			"For testing: create test key with 'openssl genrsa -3 -out test-signing-key.pem 3072'")
	}

	// Load public key
	pubKey, err := loadRSAPublicKey(pubKeyPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load public key from %s: %w", pubKeyPath, err)
	}
	
	log.Info("Loaded manifest signing public key", "path", pubKeyPath, "bits", pubKey.N.BitLen())

	return &ManifestSignatureVerifier{
		publicKey: pubKey,
	}, nil
}

// VerifyManifestSignature verifies the signature of a Gramine SGX manifest file
// According to Gramine spec:
// - manifestPath should be the .manifest.sgx file
// - signaturePath should be the .manifest.sgx.sig file (auto-detected if empty)
//
// CRITICAL SECURITY STEPS:
// 1. 定位签名文件 (.manifest.sgx.sig)
// 2. 验证manifest文件的RSA签名
// 3. 从签名文件中提取MRENCLAVE
// 4. 验证签名中的MRENCLAVE与当前运行的enclave一致
//
// NO bypass allowed - always performs full verification
func (v *ManifestSignatureVerifier) VerifyManifestSignature(manifestPath string, signaturePath string) error {
	log.Info("Step 1: Locating manifest signature file...")
	
	// Auto-detect signature path if not provided
	// Gramine convention: <app>.manifest.sgx -> <app>.manifest.sgx.sig
	if signaturePath == "" {
		if filepath.Ext(manifestPath) == ".sgx" {
			signaturePath = manifestPath + ".sig"
		} else {
			// If not .sgx extension, assume it needs .manifest.sgx.sig
			signaturePath = manifestPath + ".manifest.sgx.sig"
		}
	}
	
	// Verify signature file exists
	if _, err := os.Stat(signaturePath); err != nil {
		return fmt.Errorf("signature file not found: %s (%w)", signaturePath, err)
	}
	
	log.Info("Signature file located", "path", signaturePath)

	log.Info("Step 2: Reading manifest and signature files...")
	
	// Read manifest file (.manifest.sgx)
	manifestData, err := os.ReadFile(manifestPath)
	if err != nil {
		return fmt.Errorf("failed to read manifest file: %w", err)
	}
	
	log.Info("Manifest file read", "size", len(manifestData))

	// Read signature file (.manifest.sgx.sig)
	// Gramine signature file contains SIGSTRUCT (1808 bytes)
	signatureData, err := os.ReadFile(signaturePath)
	if err != nil {
		return fmt.Errorf("failed to read signature file %s: %w", signaturePath, err)
	}
	
	log.Info("Signature file read", "size", len(signatureData))
	
	log.Info("Step 3: Verifying RSA signature...")

	// Gramine uses SHA256 hash and RSA-3072 signature
	hash := sha256.Sum256(manifestData)

	// The signature file contains SIGSTRUCT which includes the RSA signature
	// Extract signature from SIGSTRUCT (at specific offset for Gramine)
	// SIGSTRUCT format: https://software.intel.com/content/www/us/en/develop/download/intel-sgx-sdk-developer-reference-for-linux-os.html
	if len(signatureData) < 384 {
		return fmt.Errorf("signature file too small: %d bytes", len(signatureData))
	}
	
	// Extract RSA signature from SIGSTRUCT (offset 128, length 384 for RSA-3072)
	rsaSignature := signatureData[128:512]

	// Verify RSA signature (PKCS#1 v1.5)
	err = rsa.VerifyPKCS1v15(v.publicKey, crypto.SHA256, hash[:], rsaSignature)
	if err != nil {
		return fmt.Errorf("manifest RSA signature verification failed: %w", err)
	}
	
	log.Info("✓ RSA signature verified successfully")
	
	log.Info("Step 4: Extracting and verifying MRENCLAVE...")
	
	// Extract MRENCLAVE from SIGSTRUCT (offset 960, length 32)
	if len(signatureData) < 992 {
		return fmt.Errorf("signature file too small to contain MRENCLAVE")
	}
	
	manifestMREnclave := signatureData[960:992]
	
	log.Info("MRENCLAVE from manifest signature", "mrenclave", fmt.Sprintf("%x", manifestMREnclave))
	
	// Get current enclave's MRENCLAVE from Gramine pseudo filesystem
	currentMREnclaveBytes, err := getCurrentMREnclaveFromGramine()
	if err != nil {
		return fmt.Errorf("SECURITY: Cannot retrieve current enclave MRENCLAVE: %w", err)
	}
	
	log.Info("Current enclave MRENCLAVE", "mrenclave", fmt.Sprintf("%x", currentMREnclaveBytes))
	
	// Compare MRENCLAVEs (both are now byte arrays)
	if !bytes.Equal(manifestMREnclave, currentMREnclaveBytes) {
		return fmt.Errorf("MRENCLAVE MISMATCH! Manifest MRENCLAVE does not match current enclave. " +
			"This indicates the manifest file has been tampered with or replaced. " +
			"Manifest: %x, Current: %x", manifestMREnclave, currentMREnclaveBytes)
	}
	
	log.Info("✓ MRENCLAVE verified - manifest matches current enclave")

	return nil
}

// VerifyCurrentManifest verifies the signature of the currently running manifest
// NOTE: In Gramine SGX, the manifest is verified at launch time by Gramine itself.
// This function provides additional runtime verification.
func (v *ManifestSignatureVerifier) VerifyCurrentManifest() error {
	// Public key must be available
	if v.publicKey == nil {
		return fmt.Errorf("SECURITY: Cannot verify manifest - no public key loaded. " +
			"Manifest verification is REQUIRED for security.")
	}

	// Try to find the SGX manifest file
	// Gramine standard: application should be launched with <app>.manifest.sgx
	manifestPath := os.Getenv("GRAMINE_MANIFEST_PATH")
	if manifestPath == "" {
		// Try common Gramine deployment locations
		appName := os.Getenv("GRAMINE_APP_NAME")
		if appName == "" {
			appName = "geth" // Default application name
		}

		possiblePaths := []string{
			fmt.Sprintf("/gramine/app_files/%s.manifest.sgx", appName),
			fmt.Sprintf("/gramine/%s.manifest.sgx", appName),
			fmt.Sprintf("./%s.manifest.sgx", appName),
		}

		for _, path := range possiblePaths {
			if _, err := os.Stat(path); err == nil {
				manifestPath = path
				break
			}
		}
	}

	if manifestPath == "" {
		return fmt.Errorf("cannot find manifest file for verification")
	}

	return v.VerifyManifestSignature(manifestPath, "")
}

// loadRSAPublicKey loads an RSA public key from a PEM file
// Gramine uses RSA-3072 keys for manifest signing
func loadRSAPublicKey(path string) (*rsa.PublicKey, error) {
	keyData, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read public key file: %w", err)
	}

	block, _ := pem.Decode(keyData)
	if block == nil {
		return nil, fmt.Errorf("failed to decode PEM block")
	}

	// Try parsing as PKIX public key first (standard format)
	pubKey, err := x509.ParsePKIXPublicKey(block.Bytes)
	if err != nil {
		// Try parsing as PKCS1 RSA public key
		pubKey, err = x509.ParsePKCS1PublicKey(block.Bytes)
		if err != nil {
			return nil, fmt.Errorf("failed to parse public key: %w", err)
		}
	}

	rsaKey, ok := pubKey.(*rsa.PublicKey)
	if !ok {
		return nil, fmt.Errorf("key is not an RSA public key")
	}

	// Verify key size (Gramine uses RSA-3072)
	keyBits := rsaKey.N.BitLen()
	if keyBits != 3072 {
		// Allow other key sizes but warn
		fmt.Printf("Warning: RSA key size is %d bits, Gramine standard is 3072 bits\n", keyBits)
	}

	return rsaKey, nil
}

// VerifyManifestFile is a convenience function that creates a verifier and verifies a manifest
func VerifyManifestFile(manifestPath string) error {
	verifier, err := NewManifestSignatureVerifier()
	if err != nil {
		return fmt.Errorf("failed to create manifest verifier: %w", err)
	}

	return verifier.VerifyManifestSignature(manifestPath, "")
}

// VerifyCurrentManifestFile is a convenience function that verifies the current running manifest
func VerifyCurrentManifestFile() error {
	verifier, err := NewManifestSignatureVerifier()
	if err != nil {
		return fmt.Errorf("failed to create manifest verifier: %w", err)
	}

	return verifier.VerifyCurrentManifest()
}

// ValidateManifestIntegrity performs manifest signature verification
// 
// 安全要求：
// 1. 必须找到manifest文件
// 2. 必须找到签名文件
// 3. 必须验证RSA签名
// 4. 必须验证MRENCLAVE匹配
// 5. 不允许跳过任何步骤
//
// 测试：如果需要测试，应该提供真实的测试manifest和签名文件，
// 而不是跳过验证。
func ValidateManifestIntegrity() error {
	log.Info("=== Validating Manifest Integrity ===")
	
	// Step 1: 检查运行环境 - 必须在Gramine下
	gramineVersion := os.Getenv("GRAMINE_VERSION")
	if gramineVersion == "" {
		return fmt.Errorf("SECURITY: GRAMINE_VERSION not set - manifest verification requires Gramine environment. " +
			"For testing: export GRAMINE_VERSION=test")
	}
	log.Info("Running under Gramine", "version", gramineVersion)
	
	// Step 2: 获取当前enclave的MRENCLAVE
	// 注意：不要使用RA_TLS_MRENCLAVE（那是用于对端验证的）
	// 应该从Gramine伪文件系统获取当前enclave的MRENCLAVE
	mrenclave, err := getCurrentMREnclaveFromGramine()
	if err != nil {
		return fmt.Errorf("SECURITY: Cannot get current enclave MRENCLAVE: %w. " +
			"This is REQUIRED for manifest verification.", err)
	}
	log.Info("Current enclave MRENCLAVE retrieved", "MRENCLAVE", fmt.Sprintf("%x", mrenclave[:min(16, len(mrenclave))])+"...")
	
	// Step 3: 定位manifest文件（必须存在）
	log.Info("Step 1: Locating manifest file...")
	manifestPath, err := findManifestFile()
	if err != nil {
		return fmt.Errorf("SECURITY: Cannot locate manifest file: %w. " +
			"For testing, provide a test manifest file with valid signature.", err)
	}
	log.Info("✓ Manifest file located", "path", manifestPath)
	
	// 3.2 验证签名
	verifier, err := NewManifestSignatureVerifier()
	if err != nil {
		return fmt.Errorf("failed to create manifest verifier: %w", err)
	}
	
	if err := verifier.VerifyManifestSignature(manifestPath, ""); err != nil {
		return fmt.Errorf("manifest signature verification FAILED: %w", err)
	}
	
	log.Info("✓ Manifest signature verified by application")
	
	return nil
}

// findManifestFile locates the manifest file following Gramine conventions
// 遵循Gramine规范，不硬编码路径
func findManifestFile() (string, error) {
	// Method 1: Use environment variable (Gramine standard)
	if path := os.Getenv("GRAMINE_MANIFEST_PATH"); path != "" {
		if _, err := os.Stat(path); err == nil {
			return path, nil
		}
	}
	
	// Method 2: Use current working directory + app name
	// Gramine convention: executable is in same dir as manifest
	appName := os.Getenv("GRAMINE_APP_NAME")
	if appName == "" {
		// Get app name from executable path
		if exe, err := os.Executable(); err == nil {
			appName = filepath.Base(exe)
		} else {
			appName = "geth" // fallback
		}
	}
	
	// Try: <appname>.manifest.sgx in current directory
	manifestName := appName + ".manifest.sgx"
	if _, err := os.Stat(manifestName); err == nil {
		return manifestName, nil
	}
	
	// Method 3: Check /proc/self/root (Gramine mounts)
	// 注意：这是Gramine的特殊路径，应用看到的是映射后的路径
	
	return "", fmt.Errorf("manifest file not found (tried GRAMINE_MANIFEST_PATH env var and %s)", manifestName)
}

// GetManifestPath returns the path to the SGX manifest file
// 遵循Gramine规范：优先使用环境变量，不硬编码路径
func GetManifestPath() (string, error) {
	return findManifestFile()
}

// MustVerifyManifest verifies the manifest and panics if verification fails
// This should be called at the start of sensitive operations
func MustVerifyManifest() {
	if err := ValidateManifestIntegrity(); err != nil {
		panic(fmt.Sprintf("CRITICAL: Manifest integrity validation failed: %v", err))
	}
}

// GetMRENCLAVE returns the MRENCLAVE measurement of the currently running enclave
// Uses Gramine pseudo filesystem - NOT RA_TLS_MRENCLAVE (which is for peer verification)
func GetMRENCLAVE() (string, error) {
	// Get current enclave MRENCLAVE from Gramine pseudo filesystem
	mrenclave, err := getCurrentMREnclaveFromGramine()
	if err != nil {
		return "", fmt.Errorf("failed to get current enclave MRENCLAVE: %w", err)
	}

	// Convert to hex string
	return fmt.Sprintf("%x", mrenclave), nil
}

// GetMRSIGNER returns the MRSIGNER measurement from environment
// This identifies the signer of the manifest
func GetMRSIGNER() (string, error) {
	mrsigner := os.Getenv("RA_TLS_MRSIGNER")
	if mrsigner == "" {
		mrsigner = os.Getenv("SGX_MRSIGNER")
	}

	if mrsigner == "" {
		return "", fmt.Errorf("MRSIGNER not found in environment")
	}

	return mrsigner, nil
}

// ReadContractAddressesFromManifest reads contract addresses from verified manifest
// 必须先调用 ValidateManifestIntegrity() 验证签名后才能调用此函数
func ReadContractAddressesFromManifest() (governance, security string, err error) {
// 1. 定位manifest文件
manifestPath, err := findManifestFile()
if err != nil {
return "", "", fmt.Errorf("cannot locate manifest: %w", err)
}

// 2. 再次验证签名（防御性编程）
verifier, err := NewManifestSignatureVerifier()
if err != nil {
return "", "", fmt.Errorf("failed to create verifier: %w", err)
}

if err := verifier.VerifyManifestSignature(manifestPath, ""); err != nil {
return "", "", fmt.Errorf("manifest signature verification failed: %w", err)
}

// 3. 读取manifest文件
data, err := os.ReadFile(manifestPath)
if err != nil {
return "", "", fmt.Errorf("failed to read manifest: %w", err)
}

// 4. 解析manifest文件获取环境变量
// Gramine manifest格式：loader.env.VARNAME = "value"
govAddr := parseManifestEnvVar(data, "XCHAIN_GOVERNANCE_CONTRACT")
secAddr := parseManifestEnvVar(data, "XCHAIN_SECURITY_CONFIG_CONTRACT")

if govAddr == "" || secAddr == "" {
return "", "", fmt.Errorf("contract addresses not found in manifest")
}

log.Info("Contract addresses read from manifest",
"governance", govAddr,
"security", secAddr)

return govAddr, secAddr, nil
}

// parseManifestEnvVar extracts environment variable value from manifest content
// Gramine manifest format: loader.env.VARNAME = "value"
func parseManifestEnvVar(data []byte, varName string) string {
	// Simple line-by-line parsing
	lines := bytes.Split(data, []byte("\n"))
	prefix := []byte(fmt.Sprintf("loader.env.%s", varName))
	
	for _, line := range lines {
		line = bytes.TrimSpace(line)
		if bytes.HasPrefix(line, prefix) {
			// Extract value between quotes
			parts := bytes.Split(line, []byte("\""))
			if len(parts) >= 2 {
				return string(parts[1])
			}
		}
	}
	
	return ""
}

// getCurrentMREnclaveFromGramine retrieves the MRENCLAVE of the currently running enclave
// Uses Gramine pseudo filesystem - NOT RA_TLS_MRENCLAVE which is for peer verification
func getCurrentMREnclaveFromGramine() ([]byte, error) {
	// Method 1: Read from /dev/attestation/my_target_info (Gramine pseudo-fs)
	// This file contains TARGETINFO structure where MRENCLAVE is at offset 0
	targetInfoPath := "/dev/attestation/my_target_info"
	data, err := os.ReadFile(targetInfoPath)
	if err == nil && len(data) >= 32 {
		// MRENCLAVE is first 32 bytes of TARGETINFO
		mrenclave := data[0:32]
		log.Info("Retrieved current enclave MRENCLAVE from /dev/attestation/my_target_info", 
			"mrenclave", fmt.Sprintf("%x", mrenclave))
		return mrenclave, nil
	}
	
	log.Warn("Cannot read /dev/attestation/my_target_info, trying quote method", "error", err)
	
	// Method 2: Generate a quote and extract MRENCLAVE from it  
	// SGX quote structure has MRENCLAVE at offset 112
	quote, err := generateQuoteForMREnclave()
	if err == nil && len(quote) >= 144 {
		// MRENCLAVE is at offset 112 in SGX quote structure
		mrenclave := quote[112:144]
		log.Info("Retrieved current enclave MRENCLAVE from generated quote", 
			"mrenclave", fmt.Sprintf("%x", mrenclave))
		return mrenclave, nil
	}
	
	log.Warn("Cannot generate quote for MRENCLAVE extraction", "error", err)
	
	// Method 3 (testing fallback): Use TEST_MRENCLAVE environment variable
	// NOTE: This is ONLY for testing when Gramine pseudo-fs is mocked
	testMREnclave := os.Getenv("TEST_MRENCLAVE")
	if testMREnclave != "" {
		log.Warn("⚠️  Using TEST_MRENCLAVE from environment (TESTING ONLY)",
			"mrenclave", testMREnclave)
		mrenclaveBytes := make([]byte, 32)
		_, err := hex.DecodeString(testMREnclave)
		if err == nil {
			hex.Decode(mrenclaveBytes, []byte(testMREnclave))
			return mrenclaveBytes, nil
		}
	}
	
	return nil, fmt.Errorf("SECURITY: Cannot retrieve current enclave MRENCLAVE. " +
		"Tried: /dev/attestation/my_target_info (Gramine pseudo-fs), quote generation. " +
		"This is required to verify manifest corresponds to current enclave. " +
		"For testing: export TEST_MRENCLAVE=<64-char-hex>")
}

// generateQuoteForMREnclave generates a minimal quote just to extract current MRENCLAVE
func generateQuoteForMREnclave() ([]byte, error) {
	// Write dummy report data to trigger quote generation
	userReportDataPath := "/dev/attestation/user_report_data"
	dummyData := make([]byte, 64) // SGX report data is 64 bytes
	if err := os.WriteFile(userReportDataPath, dummyData, 0600); err != nil {
		return nil, fmt.Errorf("cannot write to %s: %w", userReportDataPath, err)
	}
	
	// Read generated quote
	quotePath := "/dev/attestation/quote"
	quote, err := os.ReadFile(quotePath)
	if err != nil {
		return nil, fmt.Errorf("cannot read from %s: %w", quotePath, err)
	}
	
	return quote, nil
}
